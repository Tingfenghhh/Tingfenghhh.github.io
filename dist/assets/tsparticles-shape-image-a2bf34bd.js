import{v as e}from"./tsparticles-engine-3b45a3b7.js";const a=/(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d.]+%?\))|currentcolor/gi;async function t(e){return new Promise((a=>{e.loading=!0;const t=new Image;e.element=t,t.addEventListener("load",(()=>{e.loading=!1,a()})),t.addEventListener("error",(()=>{e.element=void 0,e.error=!0,e.loading=!1,a()})),t.src=e.source}))}async function r(e){if("svg"!==e.type)return void(await t(e));e.loading=!0;const a=await fetch(e.source);a.ok||(e.error=!0),e.error||(e.svgData=await a.text()),e.loading=!1}function o(r,o,i,s){var n,l,c;const d=function(t,r,o){const{svgData:i}=t;if(!i)return"";const s=e(r,o);if(i.includes("fill"))return i.replace(a,(()=>s));const n=i.indexOf(">");return`${i.substring(0,n)} fill="${s}"${i.substring(n)}`}(r,i,null!==(l=null===(n=s.opacity)||void 0===n?void 0:n.value)&&void 0!==l?l:1),g={color:i,data:Object.assign(Object.assign({},r),{svgData:d}),loaded:!1,ratio:o.width/o.height,replaceColor:null!==(c=o.replaceColor)&&void 0!==c?c:o.replace_color,source:o.src};return new Promise((e=>{const a=new Blob([d],{type:"image/svg+xml"}),o=URL||window.URL||window.webkitURL||window,i=o.createObjectURL(a),s=new Image;s.addEventListener("load",(()=>{g.loaded=!0,g.element=s,e(g),o.revokeObjectURL(i)})),s.addEventListener("error",(async()=>{o.revokeObjectURL(i);const a=Object.assign(Object.assign({},r),{error:!1,loading:!0});await t(a),g.loaded=!0,g.element=a.element,e(g)})),s.src=i}))}class i{constructor(){this._images=[]}addImage(e,a){const t=this.getImages(e);null==t||t.images.push(a)}destroy(){this._images=[]}draw(e,a,t,r){var o;const i=a.image,s=null==i?void 0:i.element;if(!s)return;const n=null!==(o=null==i?void 0:i.ratio)&&void 0!==o?o:1,l={x:-t,y:-t};e.globalAlpha=r,e.drawImage(s,l.x,l.y,2*t,2*t/n),e.globalAlpha=1}getImages(e){const a=this._images.find((a=>a.id===e.id));return a||(this._images.push({id:e.id,images:[]}),this.getImages(e))}getSidesCount(){return 12}loadShape(e){if("image"!==e.shape&&"images"!==e.shape)return;const a=e.container,t=this.getImages(a).images,r=e.shapeData;t.find((e=>e.source===r.src))||this.loadImageShape(a,r).then((()=>{this.loadShape(e)}))}particleInit(e,a){var t;if("image"!==a.shape&&"images"!==a.shape)return;const r=this.getImages(e).images,i=a.shapeData,s=a.getFillColor(),n=null!==(t=i.replaceColor)&&void 0!==t?t:i.replace_color,l=r.find((e=>e.source===i.src));l&&(l.loading?setTimeout((()=>{this.particleInit(e,a)})):(async()=>{var e,t;let r;r=l.svgData&&s?await o(l,i,s,a):{color:s,data:l,element:l.element,loaded:!0,ratio:i.width/i.height,replaceColor:n,source:i.src},r.ratio||(r.ratio=1);const c={image:r,fill:null!==(e=i.fill)&&void 0!==e?e:a.fill,close:null!==(t=i.close)&&void 0!==t?t:a.close};a.image=c.image,a.fill=c.fill,a.close=c.close})())}async loadImageShape(e,a){var o;const i=a.src;if(!i)throw new Error("Error tsParticles - No image.src");try{const s={source:i,type:i.substring(i.length-3),error:!1,loading:!0};this.addImage(e,s);const n=(null!==(o=a.replaceColor)&&void 0!==o?o:a.replace_color)?r:t;await n(s)}catch(s){throw new Error(`tsParticles error - ${a.src} not found`)}}}async function s(e){await e.addShape(["image","images"],new i)}export{s as l};
